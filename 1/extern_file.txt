tant qu on a des tetri


ft_solver()
	si (!ft_tetri())
		ft_solver(ft_next_square())

	return (result) = > fillit resolu




ft_tetri()
	si (!ft_test_combinaison)
		return (0)		= > passer a la grille superieure

	return (result) = > fillit resolu




ft_remove_tetri(result, tetri a enlever)

	while (!ft_isalpha(tetri))
		tetri++
	while (ft_strchr(result, *tetri))
		*ft_strchr(result, *tetri) = '.'

	return (result) = > retourne result sans le tetri




ft_next_square(sqrt actuelle)

	k = ft_sqrt(sqrt_actuelle) + 1
	return (k * k) = > retourne la grille suivante




ft_test_combinaison()

	si (ft_test_tetri() == 1)
		return (ft_test_combinaison(ft_next_tetri))
	si (ft_test_tetri() == 0)
		return (ft_test_combinaison(ft_move_tetri_precedent))

	return (result) = > fillit resolu




ft_test_tetri(result, tetri)

	while (!ft_strdift(&result[j], tmp))
		j++;
	if (ft_strlen(tmp) + j > ft_strlen(result))
		return (0);

	while (tmp[i])
	{
		if (tmp[i] != '.')
			result[j] = tmp[i];
		i++;
		j++;
	}




ft_move_tetri_precedent()
	ft_remove_tetri(tetri precedent)
	return (tetri precedent + '.')
	return (0) = > je peux plus le deplacer




ft_next_tetri()
	return (tetri suivant)
	return (0) = > plus de tetri
